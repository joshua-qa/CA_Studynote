## 명령어 세트
CPU의 기능은 명령어들에 의하여 결정되며, 그 종류와 수는 CPU마다 약간씩 다르다. 이런 명령어들의 집합을 명령어 세트(instruction set) 라 부르는데, 명령어 세트를 설계하기 위해서는 몇 가지 사항들을 먼저 결정해야 한다.

* 연산 종류
* 데이터 형태
* 명령어 형식
* 주소지정 방식

### 연산의 종류
CPU가 수행할 수 있는 연산(동작)들의 종류는 컴퓨터에 따라 매우 다양하지만, 어떤 컴퓨터라도 반드시 수행 할 수 있어야 하는 기본적인 연산들이 존재한다.

* 데이터 전송
  * 레지스터 ↔️ 레지스터, 레지스터 ↔️ 기억장치, 기억장치 ↔️ 기억장치 간에 데이터를 이동하는 동작
  * 이 과정에서 기억장치의 주소를 계산하는 경우도 존재
* 산술 연산
  * 덧셈, 뺄셈, 곱셈, 나눗셈과 같은 기본적인 산술 연산들
  * 부호를 가진 정수 및 부동소수점 수(floating-point number)에 대한 산술적 연산도 포함
* 논리 연산
  * 데이터의 각 비트들 간에 대한 논리 연산을 수행
  * AND, OR, NOT, exclusive-OR 등..
* 입출력(I/O)
  * CPU와 외부 장치들 간의 데이터 이동을 위한 동작들을 수행
  * 특수한 I/O 명령어들과 주소지정 방식이 필요
* 프로그램 제어
  * 명령어 실행 순서를 변경하는 연산들이 필요
  * 분기(branch)와 서브루틴 호출(subroutine call) 등이 있으며, 서브루틴 호출에는 두 가지 기본적인 명령어들이 필요
    * CALL : 서브루틴을 호출하는 명령어
    * RET : 서브루틴 -> 원래 프로그램으로 복귀(return)시키는 명령어
  * CALL, RET 명령어 실행에는 스택이 반드시 사용된다. 
    * CALL 명령어가 실행되어 서브루틴으로 분기될 때는 복귀할 주소를 스택에 저장해야함
    * 복귀 주소는 CALL 명령어가 실행되고 있는 현재 Program Counter에 저장되어 있는 내용

### 연산의 종류

명령어는 CPU에 의해 실행될 때 제공해야 할 모든 정보를 포함하고 있어야함

* 연산 코드(Operation Code)
  * 수행될 연산을 지정 (LOAD, ADD 등)
* 오퍼랜드(Operand)
  * 연산을 수행하는데 필요한 데이터 혹은 데이터의 주소
  * 각 연산은 한 개 또는 두 개의 입력 오퍼랜드, 한 개의 결과 오퍼랜드를 가질 수 있고, 데이터는 CPU 레지스터 또는 기억장치에 위치함
* 다음 명령어 주소(Next Instruction Address)
  * 현재의 명령어 실행이 완료된 후, 다음 명령어를 인출할 위치를 나타냄
  * 순차적으로 다음 명령어가 실행되는 경우에는 필요하지 않으나, 분기 혹은 호출 명령어와 같이 실행 순서를 변경하는 경우에는 필요



명령어는 일련의 비트들에 의해 표현되고 그 비트의 수는 정보를 나타내는데 필요한 만큼 사용된다. 비트들은 용도에 따라 몇 개의 필드들로 나눌 수 있는데, 필드에 대해 정의한 것을 명령어 형식(instruction format)이라 부른다.

명령어 형식(instruction format) : 명령어를 구성하는 필드의 종류와 개수, 배치 방식 및 필드 당 비트 수를 정의한 형식

비트 수는 일반적으로 CPU가 한 번에 처리할 수 있는 데이터의 길이와 같으며, 따라서 명령어의 필드 수와 길이는 그 범위 내에서 결정되어야 한다.

예시) 16비트 CPU의 명령어 길이는 16비트이다.

```
16비트 명령어 형식의 예
     4        4             8
--------------------------------------
| 연산코드 | 오퍼랜드 1 |    오퍼랜드 2     |
--------------------------------------
|<-------------  16비트  ------------>|

연산 코드의 길이가 4비트이므로 CPU는 2^4 = 16가지의 연산 수행 가능
```



연산 코드의 길이가 늘어날 수록 CPU는 더 많은 종류의 연산들을 지정하고 수행할 수 있다.
오퍼랜드 필드는 오퍼랜드가 아래 세 가지 중에 어떤 것인지에 따라 필요한 비트 수가 달라질 수 있고, 배정되는 비트들의 수에 따라 각각의 범위가 결정된다.

* 데이터
  * 표현 가능한 수의 크기를 결정
* 기억장치 주소
  * CPU가 오퍼랜드 인출을 위하여 직접 주소를 지정할 수 있는 기억장치 영역의 범위를 결정
* 레지스터 번호
  * 데이터 저장에 사용될 수 있는 내부 레지스터들의 수가 결정



```
예제) 위의 그림(16비트 명령어 형식의 예)에서 연산 코드를 5비트 / 오퍼랜드1을 2비트 / 오퍼랜드2를 9비트로 변경했을 때 연산의 수와 사용 가능한 레지스터 수, 주소지정 할 수 있는 기억장치 주소 영역은?
-> 연산 코드가 5비트이므로 연산 종류는 2^5 = 32가지, 오퍼랜드1이 2비트이므로 레지스터의 수는 2^2 = 4개
-> 기억장치 주소 영역은 오퍼랜드2가 9비트이기 때문에 2^9 = 512, 0~511번지

예제2) 오퍼랜드1 필드와 오퍼랜드2 필드를 합하여 하나의 오퍼랜드 필드로 하고, 2의 보수 데이터를 저장했을 때 그 표현 범위는?
-> 오퍼랜드1 + 오퍼랜드2 = 11비트이므로 2^11 = 2048
-> 2의 보수 데이터의 표현 범위는 -2^10 ~ +(2^10-1) = -1024 ~ +1023
```



* 1 주소 명령어 (one-address instruction) : 명령어가 한 개의 오퍼랜드만 포함
* 2 주소 명령어 (two-address instruction) : 명령어가 두 개의 오퍼랜드를 포함
* 3 주소 명령어 (three-address instruction) : 명령어가 세 개의 오퍼랜드를 포함

2 주소 명령어나 3 주소 명령어를 사용하면 프로그램이 짧아진다는 장점이 있으나, 레지스터의 수와 기억장치 용량이 고정된 상태에서 사용하면 명령어의 비트 수가 늘어나게 되어 이에 따른 단점도 생긴다. 결과적으로 프로그램의 길이는 줄어드나 기억장치 용량은 별로 줄어들지 않고 명령어 해독 과정이 더 복잡해진다는 단점이 있다.



### 주소지정 방식

일반적으로 명령어 비트수의 수는 CPU가 처리하는 단어(word)의 길이와 같도록 제한되기 때문에, 사용자로 하여금 가능한 한 다양한 방법으로 오퍼랜드를 지정하고 더 큰 용량의 기억장치를 사용할 수 있도록 하기 위하여 여러가지 주소지정 방식(addressing mode)들이 고안되었다.

주소지정 방식(addressing mode) : 주소 비트들을 이용하여 오퍼랜드의 유효 주소(effective address)를 결정하는 방법

* 직접 주소지정 방식
  * 명령어 내 오퍼랜드 필드의 내용이 데이터의 유효 주소로 사용되는 가장 간단한 방식
  * 데이터 인출을 위하여 한 번의 기억장치 액세스만 필요하며, 유효 주소 결정을 위한 다른 절차나 계산이 필요하지 않다는 장점이 있음
  * 직접 액세스할 수 있는 기억장치 주소 공간이 오퍼랜드 필드의 비트 수에 의해 제한되는 것이 단점
* 간접 주소지정 방식
  * 오퍼랜드가 가리키는 기억장치의 내용을 유효 주소로 사용하여 연산에 필요한 데이터를 인출하는 방식
  * 명령어 형식에 간접 비트가 포함되어야 함
  * 두 번의 기억장치 액세스가 실행 사이클 동안에 필요하다는 것이 단점
    * 첫 번째 액세스는 주소를 읽어오기 위한 것이고, 두 번째 액세스는 그 주소가 지정하는 위치로부터 실제 데이터를 인출하기 위함
  * 여러 단계의 간접 지정도 가능하며, 이러한 방식을 다단계 혹은 연속적 간접 주소지정 방식이라고 부름
    * 특별한 프로그래밍 기법을 위해 사용되기도 하지만 한 개의 오퍼랜드를 인출하기 위하여 여러 번의 기억장치 참조들이 필요하다는 단점이 있음
* 묵시적 주소지정 방식
  * ​명령어 실행에 사용될 데이터가 묵시적으로 지정되어 있는 방식
* 즉시 주소지정 방식
  * 명령어 내에 포함되어 있는 데이터를 연산에 직접 사용하는 방식
  * 데이터 인출 과정이 별도로 필요하지 않아 실행 사이클이 짧아진다는 장점이 있으나, 오퍼랜드 필드의 비트 수에 의해 사용할 수 있는 수의 크기가 정해져있다는 단점이 있음
* 레지스터 주소지정 방식
  * 명령어의 오퍼랜드가 가리키는 레지스터에 저장되어 있는 데이터를 연산에 사용하는 방식
  * 명령어 형식에서 오퍼랜드 필드의 비트 수가 적어도 되고, 데이터 인출을 위하여 기억장치를 액세스할 필요가 없다는 장점이 있으며 CPU 내부 레지스터에 대한 액세스 시간이 주기억장치 액세스 시간보다 더 짧기 때문에 명령어 실행 시간도 짧아짐
  * 데이터가 저장될 수 있는 위치가 CPU 내부 레지스터로 제한된다는 단점이 있음
* 레지스터 간접 주소지정 방식
  * 지정된 레지스터의 내용을 유효 주소로 사용하여, 그 주소가 가리키는 기억장치로부터 읽어온 데이터를 연산에 사용하는 방식
* 변위 주소지정 방식
  * 직접 주소지정 방식과 레지스터 간접 주소지정 방식이 조합된 방식이며, 유연성이 높음
  * 지정된 레지스터의 내용과 명령어 내 오퍼랜드(변위)를 더하여 유효 주소를 결정하는 주소지정 방식
  * 널리 사용되고 있는 방식으로 상대 주소지정 방식 / 인덱스 주소지정 방식 / 베이스-레지스터 주소지정 방식이 있음

